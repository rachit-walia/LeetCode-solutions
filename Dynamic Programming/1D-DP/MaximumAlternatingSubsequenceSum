1911--  Maximum Alternating Subsequence Sum

Recusrion-- will give TLE

class Solution {
    int n;

    long solve(int idx, int[] nums, boolean flag) {
        if (idx >= n) {
            return 0;
        }

        long skip = solve(idx + 1, nums, flag);
        long val = nums[idx];
        if (!flag) {
            val = -val;
        }

        long take = solve(idx + 1, nums, !flag) + val;

        return Math.max(skip, take);
    }

    public long maxAlternatingSum(int[] nums) {
        n = nums.length;
        return solve(0, nums, true); // true corresponds to '+'
    }
}

// Recursion + Memoization

class Solution {
    int n;
    Long[][] t = new Long[100001][2]; 

    long solve(int idx, int[] nums, boolean isEven) {
        if (idx >= n) return 0;

        int parity = isEven ? 1 : 0;
        if (t[idx][parity] != null) return t[idx][parity];

        long skip = solve(idx + 1, nums, isEven);
        long val = nums[idx];
        if (!isEven) val = -val;

        long take = solve(idx + 1, nums, !isEven) + val;

        return t[idx][parity] = Math.max(skip, take);
    }

    public long maxAlternatingSum(int[] nums) {
        n = nums.length;
        return solve(0, nums, true); 
    }
}
